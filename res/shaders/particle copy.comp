#version 430 

layout( local_size_x = 1024, local_size_y = 1, local_size_z = 1 ) in;

layout(std140, binding=0) buffer Pos
{
    vec4 Positions[];
};

layout(std140, binding=1) buffer Vel
{
    vec4 Velocities[];
};

layout(std140, binding=2) buffer Col
{
    vec4 Colors[];
};

layout(std430, binding=3) readonly buffer particleIndex
{
    uint particleIndices[];
};

layout(std430, binding=4) readonly buffer prefixSum
{
    uint prefixSums[];
};

layout(std430, binding=5) buffer bucketSize
{
    uint bucketSizes[];
};

uniform vec3 boundingBoxLow;
uniform vec3 boundingBoxHigh;
uniform uvec3 gridRes;
uniform int numBoids;

const float DT = 0.1;
const float cohesion_factor = 0.01;
const float separation_range = 1.0;
const float alignment_factor = 0.125;
const float view_range = 3.0;
const float max_vel = 2.0;

vec3 separation_vector = vec3(0.f);
vec3 alignment_vector = vec3(0.f);
vec3 cohesion_vector = vec3(0.f);

vec3 diagonal = boundingBoxHigh-boundingBoxLow;
uint num_in_range = 0;
uint currentParticleIndex;

struct boid_t
{
    vec3 pos;
    vec3 vel;
};

float vecLen (vec3 v)
{
	return sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
}

vec3 normalize (vec3 v)
{
	return v / (vecLen(v)+0.0001);
}

vec3 limit(vec3 v, float limit){
    if (dot(v, v) > limit * limit){
        return normalize(v) * limit;
    }
    return v;
}

boid_t get_boid(uint gid) {
    boid_t b;
    b.pos = Positions[gid].xyz;
    b.vel = Velocities[gid].xyz;
    return b;
}

void update_boid(uint gid, boid_t b) {
    Positions[gid].xyz = b.pos;
    Velocities[gid].xyz = b.vel;
}

vec3 getQuadrant(vec3 pos) {
    vec3 centeredPos = pos - boundingBoxLow - diagonal/2;
    vec3 quadrant = vec3(1.0f);
    if (centeredPos.x<=0) {
        quadrant.x = -1;
    }
    if (centeredPos.y<=0) {
        quadrant.y = -1;
    }
    if (centeredPos.z<=0) {
        quadrant.z = -1;
    }
    return quadrant;
}

vec3 closestWrappedPos(vec3 fromPos, vec3 otherPos) 
{
    // Are we in upper region?
    vec3 wrappedPos = otherPos;
    vec3 fromQuadrant = getQuadrant(fromPos);
    vec3 otherQuadrant = getQuadrant(otherPos);

    if (fromQuadrant.x == -otherQuadrant.x) {
        wrappedPos.x += diagonal.x;
    }
    if (fromQuadrant.y == -otherQuadrant.y) {
        wrappedPos.y += diagonal.y;
    }
    if (fromQuadrant.z == -otherQuadrant.z) {
        wrappedPos.z += diagonal.z;
    }
    return wrappedPos;
}

// For explanation, see http://www.vergenet.net/~conrad/boids/pseudocode.html
vec3 separation(uint gid) {
    vec3 c = vec3(0.f);
    boid_t current_boid = get_boid(gid);
    for (uint i = 1; i < numBoids; i++) {
        uint otherID = (gid+i)%numBoids;
        boid_t other_boid = get_boid(otherID);
        vec3 otherPos = other_boid.pos;
        float dist = distance(otherPos, current_boid.pos);
        // if (!(dist < view_range)) {
        //     otherPos = closestWrappedPos(current_boid.pos, otherPos);
        //     dist = distance(otherPos, current_boid.pos);
        // }
        if (dist < view_range && dist < separation_range) {
            c -= (otherPos-current_boid.pos);
        }

    }
    return c;
}

vec3 alignment(uint gid) {
    boid_t current_boid = get_boid(gid);
    vec3 v = current_boid.vel;
    uint num_boids_affecting = 0;
    for (uint i = 1; i < numBoids; i++) {
        uint otherID = (gid+i)%numBoids;
        boid_t other_boid = get_boid(otherID);

        vec3 otherPos = other_boid.pos;
        float dist = distance(otherPos, current_boid.pos);
        // if (!(dist < view_range)) {
        //     otherPos = closestWrappedPos(current_boid.pos, otherPos);
        //     dist = distance(otherPos, current_boid.pos);
        // }

        if (dist < view_range) {
            v += other_boid.vel;
            num_boids_affecting++;
        }

    }
    if (num_boids_affecting == 0) return vec3(0.f);
    v /= num_boids_affecting;
    return v*alignment_factor;
}

vec3 cohesion(uint gid) {
    boid_t current_boid = get_boid(gid);
    vec3 flock_center = vec3(0.f);
    uint num_boids_affecting = 0;
    for (uint i = 1; i < numBoids; i++) {
        uint otherID = (gid+i)%numBoids;
        boid_t other_boid = get_boid(otherID);
        vec3 otherPos = other_boid.pos;
        float dist = distance(otherPos, current_boid.pos);
        // if (!(dist < view_range)) {
        //     otherPos = closestWrappedPos(current_boid.pos, otherPos);
        //     dist = distance(otherPos, current_boid.pos);
        // }
        if (dist < view_range) {
            flock_center += otherPos;
            num_boids_affecting++;
        }

    }
    if (num_boids_affecting == 0) return flock_center;
    flock_center /= num_boids_affecting;
    return (flock_center-current_boid.pos)*cohesion_factor;
}

uint flattenCellID(int x, int y, int z) {
    return uint(gridRes.x * gridRes.y * z + gridRes.x * y + x);
}

ivec3 getCellIDfromPos(vec3 pos)
{
    // vec3 diagonal = boundingBoxHigh-boundingBoxLow;
    vec3 range = diagonal/gridRes;
    return ivec3((pos-boundingBoxLow)/range);
    // return flattenCellID(vgridIdx.x, vgridIdx.y, vgridIdx.z);
}

uint getFlatCellIDfromPos(vec3 pos) {
    ivec3 cellID = getCellIDfromPos(pos);
    return flattenCellID(cellID.x, cellID.y, cellID.z);
}

void flock(uint particleID) 
{
    if (currentParticleIndex == particleID) {
        return;
    }

    boid_t current_boid = get_boid(currentParticleIndex);
    boid_t other_boid = get_boid(particleID);
    vec3 otherPos = other_boid.pos;
    // mod(((current_boid.pos + current_boid.vel*DT) - boundingBoxLow + diagonal), diagonal) + boundingBoxLow
    float dist = distance(otherPos, current_boid.pos);
    // if (!(dist < view_range)) {
    //     otherPos = closestWrappedPos(current_boid.pos, otherPos);
    //     dist = distance(otherPos, current_boid.pos);
    // }

    if (dist < view_range) {
        num_in_range++;

        // COHESION
        cohesion_vector += otherPos;

        // ALIGNMENT
        alignment_vector += other_boid.vel;

        // SEPARATION
        if (dist < separation_range) {
            separation_vector -= (otherPos-current_boid.pos);
        }
    }
}

void flockInCell(uint x, uint y, uint z) {
    // uint cellID = flattenCellID(x, y, z);
    // uint cellID = z * gridRes.x * gridRes.y + y * gridRes.x + x;
    // // Do I contain any particles/boids?
    // uint particleCount;
    // if (cellID == 0) {
    //     particleCount = prefixSums[0];
    // } else {
    //     particleCount = prefixSums[cellID]-prefixSums[cellID-1];
    // }

    // if (particleCount==0) {
    //     // The cell is empty
    //     return;
    // }
    // for (int i = 0; i < particleCount; i++) {
    //     uint particleIndex = prefixSums[cellID]-particleCount+i;
    //     flock(particleIndices[particleIndex]);
    // }
    uint id = z * gridRes.x * gridRes.y + y * gridRes.x + x;
    uint start;
    if (id == 0) {
        start = 0;
    } else {
        start = prefixSums[id-1];
    }
    uint end = prefixSums[id];

    if (start == end)
        return;

    for (uint i = start; i < end; ++i)
        flock(particleIndices[i]);
}



void main() {
    uint gid = gl_GlobalInvocationID.x;
    if (gid > numBoids) {
        return;
    }
    // currentParticleIndex = particleIndices[gid];
    currentParticleIndex = gid;
    boid_t current_boid = get_boid(currentParticleIndex);

    // ivec3 cellID = getCellIDfromPos(current_boid.pos);
    // for (int xOffset = -1; xOffset <= 1; xOffset++) {
    //     // Check that our neighbours exist in x:
    //     int cellIDx = cellID.x + xOffset;
    //     if ((cellIDx<0) || (cellIDx>gridRes.x-1)) {
    //         break;
    //     }
    //     for (int yOffset = -1; yOffset <= 1; yOffset++) {
    //         int cellIDy = cellID.y + yOffset;
    //         if ((cellIDy<0) || (cellIDy>gridRes.y-1)) {
    //             break;
    //         }
    //         for (int zOffset = -1; zOffset <= 1; zOffset) {
    //             int cellIDz = cellID.z+zOffset;
    //             if ((cellIDz<0) || (cellIDz>gridRes.z-1)) {
    //                 break;
    //             }
    //             flockInCell(uint(cellID.x+xOffset), uint(cellID.y+yOffset), uint(cellID.z+zOffset));
    //         }
    //     }
    // }

    // ivec3 cellID = getCellIDfromPos(current_boid.pos);
    // for (int xOffset = -1; xOffset <= 1; xOffset++) {
    //     // Check that our neighbours exist in x:
    //     uint cellIDx = uint(clamp(cellID.x + xOffset, 0, gridRes.x-1));
    //     for (int yOffset = -1; yOffset <= 1; yOffset++) {
    //         uint cellIDy = uint(clamp(cellID.y + yOffset, 0, gridRes.y-1));
    //         for (int zOffset = -1; zOffset <= 1; zOffset) {
    //             uint cellIDz = uint(clamp(cellID.z+zOffset, 0, gridRes.z-1));
    //             flockInCell(cellIDx, cellIDy, cellIDz);
    //         }
    //     }
    // }
    uint cellID = getFlatCellIDfromPos(current_boid.pos);

    uint gridXY = gridRes.x * gridRes.y;
    uint z = cellID / gridXY;
    uint znext = (z + 1 + gridRes.z) % gridRes.z;
    uint zprev = (z - 1 + gridRes.z) % gridRes.z;
    uint tmpy = cellID - (z * gridXY);
    uint y = tmpy / gridRes.x;
    uint ynext = (y + 1 + gridRes.y) % gridRes.y;
    uint yprev = (y - 1 + gridRes.y) % gridRes.y;
    uint x = tmpy - y * gridRes.x;
    uint xnext = (x + 1 + gridRes.x) % gridRes.x;
    uint xprev = (x - 1 + gridRes.x) % gridRes.x;
    
    flockInCell(xprev, yprev, zprev);
    flockInCell(x, yprev, zprev);
    flockInCell(xnext, yprev, zprev);

    flockInCell(xprev, y, zprev);
    flockInCell(x, y, zprev);
    flockInCell(xnext, y, zprev);

    flockInCell(xprev, ynext, zprev);
    flockInCell(x, ynext, zprev);
    flockInCell(xnext, ynext, zprev);

    flockInCell(xprev, yprev, z);
    flockInCell(x, yprev, z);
    flockInCell(xnext, yprev, z);

    flockInCell(xprev, y, z);
    flockInCell(x, y, z);
    flockInCell(xnext, y, z);

    flockInCell(xprev, ynext, z);
    flockInCell(x, ynext, z);
    flockInCell(xnext, ynext, z);

    flockInCell(xprev, yprev, znext);
    flockInCell(x, yprev, znext);
    flockInCell(xnext, yprev, znext);

    flockInCell(xprev, y, znext);
    flockInCell(x, y, znext);
    flockInCell(xnext, y, znext);

    flockInCell(xprev, ynext, znext);
    flockInCell(x, ynext, znext);
    flockInCell(xnext, ynext, znext);


    // vec3 coh = cohesion(currentParticleIndex);
    // vec3 sep = separation(currentParticleIndex);
    // vec3 alig = alignment(currentParticleIndex);
    // current_boid.vel += coh+sep+alig;
    if (num_in_range != 0) {
        current_boid.vel += DT*(separation_vector + (cohesion_vector*cohesion_factor + alignment_vector*alignment_factor)/num_in_range);
    }
    current_boid.vel = limit(current_boid.vel, max_vel);
    current_boid.pos += current_boid.vel*DT;

    // current_boid.pos = mod(((current_boid.pos + current_boid.vel*DT) - boundingBoxLow + diagonal), diagonal) + boundingBoxLow;
    // TODO: Find some way to do this without conditional branching 
    // (I think it's bad for performance?)
    // WRAP AROUND
    // vec3 diagonal = boundingBoxHigh-boundingBoxLow;
    // if (current_boid.pos.x < boundingBoxLow.x) {
    //     current_boid.pos.x += diagonal.x;
    // } else if (current_boid.pos.x > boundingBoxHigh.x) {
    //     current_boid.pos.x -= -diagonal.x;
    // }
    // if (current_boid.pos.y < boundingBoxLow.y) {
    //     current_boid.pos.y += diagonal.y;
    // } else if (current_boid.pos.y > boundingBoxHigh.y) {
    //     current_boid.pos.y -= -diagonal.y;
    // }
    // if (current_boid.pos.z < boundingBoxLow.z) {
    //     current_boid.pos.z += diagonal.z;
    // } else if (current_boid.pos.z > boundingBoxHigh.z) {
    //     current_boid.pos.z -= -diagonal.z;
    // }

    // BOUNCE
    if ((current_boid.pos.x < boundingBoxLow.x) && (current_boid.vel.x < 0.0)) {
        current_boid.vel.x *= -1;
        current_boid.pos.x += current_boid.vel.x*DT;
    } else if ((current_boid.pos.x > boundingBoxHigh.x) && (current_boid.vel.x >= 0.0)) {
        current_boid.vel.x *= -1;
        current_boid.pos.x += current_boid.vel.x*DT;
    }

    if ((current_boid.pos.y < boundingBoxLow.y) && (current_boid.vel.y < 0.0)) {
        current_boid.vel.y *= -1;
        current_boid.pos.y += current_boid.vel.y*DT;
    } else if ((current_boid.pos.y > boundingBoxHigh.y) && (current_boid.vel.y >= 0.0)) {
        current_boid.vel.y *= -1;
        current_boid.pos.y += current_boid.vel.y*DT;
    }

    if ((current_boid.pos.z < boundingBoxLow.z) && (current_boid.vel.z < 0.0)) {
        current_boid.vel.z *= -1;
        current_boid.pos.z += current_boid.vel.z*DT;
    } else if ((current_boid.pos.z > boundingBoxHigh.z) && (current_boid.vel.z >= 0.0)) {
        current_boid.vel.z *= -1;
        current_boid.pos.z += current_boid.vel.z*DT;
    }
    
    update_boid(currentParticleIndex, current_boid);


    // Update bucket sizes
    // uint newCellIdx = getFlatCellIDfromPos(current_boid.pos);
    // atomicAdd(bucketSizes[newCellIdx], 1);
}

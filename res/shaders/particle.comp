#version 430 

layout( local_size_x = 128, local_size_y = 1, local_size_z = 1 ) in;

layout(std140, binding=0) buffer Pos
{
    vec4 Positions[];
};

layout(std140, binding=1) buffer Vel
{
    vec4 Velocities[];
};

layout(std140, binding=2) buffer Col
{
    vec4 Colors[];
};

layout(std430, binding=3) readonly buffer particleIndex
{
    uint particleIndices[];
};

uniform vec3 boundingBoxLow;
uniform vec3 boundingBoxHigh;
uniform int numBoids;

const float DT = 0.1;
const float cohesion_factor = 0.01;
const float separation_range = 1.0;
const float alignment_factor = 0.125;
const float view_range = 3.0;
const float max_vel = 2.0;

struct boid_t
{
    vec3 pos;
    vec3 vel;
};

float vecLen (vec3 v)
{
	return sqrt(v.x*v.x + v.y*v.y + v.z*v.z);
}

vec3 normalize (vec3 v)
{
	return v / (vecLen(v)+0.0001);
}

vec3 limit(vec3 v, float limit){
    if (dot(v, v) > limit * limit){
        return normalize(v) * limit;
    }
    return v;
}

boid_t get_boid(uint gid) {
    boid_t b;
    b.pos = Positions[gid].xyz;
    b.vel = Velocities[gid].xyz;
    return b;
}

void update_boid(uint gid, boid_t b) {
    Positions[gid].xyz = b.pos;
    Velocities[gid].xyz = b.vel;
}

// For explanation, see http://www.vergenet.net/~conrad/boids/pseudocode.html
vec3 separation(uint gid) {
    vec3 c = vec3(0.f);
    boid_t current_boid = get_boid(gid);
    for (uint i = 1; i < numBoids; i++) {
        uint otherID = (gid+i)%numBoids;
        boid_t other_boid = get_boid(otherID);
        float dist = distance(other_boid.pos, current_boid.pos);
        if (dist < view_range && dist < separation_range) {
            c -= (other_boid.pos-current_boid.pos);
        }

    }
    return c;
}

vec3 alignment(uint gid) {
    boid_t current_boid = get_boid(gid);
    vec3 v = current_boid.vel;
    uint num_boids_affecting = 0;
    for (uint i = 1; i < numBoids; i++) {
        uint otherID = (gid+i)%numBoids;
        boid_t other_boid = get_boid(otherID);
        if (distance(other_boid.pos, current_boid.pos) < view_range) {
            v += other_boid.vel;
            num_boids_affecting++;
        }

    }
    if (num_boids_affecting == 0) return vec3(0.f);
    v /= num_boids_affecting;
    return v*alignment_factor;
}

vec3 cohesion(uint gid) {
    boid_t current_boid = get_boid(gid);
    vec3 flock_center = vec3(0.f);
    uint num_boids_affecting = 0;
    for (uint i = 1; i < numBoids; i++) {
        uint otherID = (gid+i)%numBoids;
        boid_t other_boid = get_boid(otherID);
        if (distance(other_boid.pos, current_boid.pos) < view_range) {
            flock_center += other_boid.pos;
            num_boids_affecting++;
        }

    }
    if (num_boids_affecting == 0) return flock_center;
    flock_center /= num_boids_affecting;
    return (flock_center-current_boid.pos)*cohesion_factor;
}

void main() {
    uint gid = gl_GlobalInvocationID.x;
    uint particleIndex = particleIndices[gid];
    boid_t current_boid = get_boid(particleIndex);

    vec3 diagonal = boundingBoxHigh-boundingBoxLow;

    vec3 coh = cohesion(particleIndex);
    vec3 sep = separation(particleIndex);
    vec3 alig = alignment(particleIndex);
    current_boid.vel += coh+sep+alig;
    current_boid.vel = limit(current_boid.vel, max_vel);
    current_boid.pos += current_boid.vel*DT;

    // TODO: Find some way to do this without conditional branching 
    // (I think it's bad for performance?)
    // WRAP AROUND
    // if (current_boid.pos.x < boundingBoxLow.x) {
    //     current_boid.pos.x += diagonal.x;
    // } else if (current_boid.pos.x > boundingBoxHigh.x) {
    //     current_boid.pos.x -= -diagonal.x;
    // }
    // if (current_boid.pos.y < boundingBoxLow.y) {
    //     current_boid.pos.y += diagonal.y;
    // } else if (current_boid.pos.y > boundingBoxHigh.y) {
    //     current_boid.pos.y -= -diagonal.y;
    // }
    // if (current_boid.pos.z < boundingBoxLow.z) {
    //     current_boid.pos.z += diagonal.z;
    // } else if (current_boid.pos.z > boundingBoxHigh.z) {
    //     current_boid.pos.z -= -diagonal.z;
    // }

    // BOUNCE
    if ((current_boid.pos.x < boundingBoxLow.x) && (current_boid.vel.x < 0.0)) {
        current_boid.vel.x *= -1;
    } else if ((current_boid.pos.x > boundingBoxHigh.x) && (current_boid.vel.x >= 0.0)) {
        current_boid.vel.x *= -1;
    }

    if ((current_boid.pos.y < boundingBoxLow.y) && (current_boid.vel.y < 0.0)) {
        current_boid.vel.y *= -1;
    } else if ((current_boid.pos.y > boundingBoxHigh.y) && (current_boid.vel.y >= 0.0)) {
        current_boid.vel.y *= -1;
    }

    if ((current_boid.pos.z < boundingBoxLow.z) && (current_boid.vel.z < 0.0)) {
        current_boid.vel.z *= -1;
    } else if ((current_boid.pos.z > boundingBoxHigh.z) && (current_boid.vel.z >= 0.0)) {
        current_boid.vel.z *= -1;
    }
    
    update_boid(particleIndex, current_boid);
}

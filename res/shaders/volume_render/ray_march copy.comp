#version 430

layout(binding=0) uniform sampler3D perlinWorley; 
// Weather contains [coverage, cloud type, 0, 1]
layout(binding=1) uniform sampler2D weather;
layout(binding=2) uniform sampler2D depth;

uniform vec3 VolumeGridSize;
uniform vec3 AABBmin;
uniform vec3 AABBmax;

uniform float StepSize;

uniform mat4 inv_vp;
uniform mat4 inv_view;
uniform mat4 inv_proj;
uniform mat4 vp;
uniform vec4 viewport;

uniform vec3 light_direction;
uniform float near = 0.1;
uniform float far = 350.0;


layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba8, binding = 0) uniform image2D OutputFrag;

// #define FAST

#ifdef FAST
	#define STEPS_PRIMARY 16
#else
	#define STEPS_PRIMARY 200
#endif


// Maps a value from one range to another
float remap(float original_value, float original_min, float original_max, float new_min, float new_max)
{
    return (((original_value - original_min) / (original_max - original_min)) * (new_max - new_min)) + new_min;
}

struct Ray {
  vec3 origin;
  vec3 dir;
  // float cosA;
};
//=============== COORDINATE UTILITIES ===============//
bool isInsideAABB(vec3 p)
{
  float eps = 1e-4;
  return (p.x > AABBmin.x-eps) && (p.y > AABBmin.y-eps) && (p.z > AABBmin.z-eps) &&
         (p.x < AABBmax.x+eps) && (p.y < AABBmax.y+eps) && (p.z < AABBmax.z+eps);
}

bool IntersectBox (Ray r, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar)
{
  vec3 invR = vec3(1.0) / r.dir;
  
  vec3 tbbmin = invR * (boxmin - r.origin);
  vec3 tbbmax = invR * (boxmax - r.origin);
   
  vec3 tmin = min(tbbmin, tbbmax);
  vec3 tmax = max(tbbmin, tbbmax);
  
  tnear = max(max(tmin.x, tmin.y), tmin.z);
  tfar  = min(min(tmax.x, tmax.y), tmax.z);

  return tfar > tnear;
}

bool RayAABBIntersection (Ray r, vec3 bbmin, vec3 bbmax, 
                          out float rtnear, out float rtfar)
{
 
  float tnear, tfar;
  bool hit = IntersectBox(r, bbmin, bbmax, tnear, tfar);

  tnear = max(tnear, 0.0);

  rtnear = tnear;
  rtfar  = tfar;

  return hit;
}

vec3 uvwFromWorldPos(vec3 pos)
{
  vec3 bbsize = AABBmax-AABBmin;

  // Bring pos to world origin
  vec3 centered_pos = pos-AABBmin;

  // Divide by bbsize to get coordinates on [0,1]
  return clamp(centered_pos/bbsize, vec3(0.0), vec3(1.0));
}


// Finds fragment coordinate fragCoord.x = [0,1920], fragCoord.y=[0,1080]
// and converts it to normalized device coordinates [-1, 1]
vec3 fragToClipSpace(uvec2 fragCoord)
{
  vec2 ndc = 2.0*vec2(fragCoord.xy-viewport.xy)/viewport.zw - 1.0;
  return vec3(ndc, -1.0);
}

vec2 fragCoordToUV(uvec2 fragCoord)
{
  return fragCoord/(viewport.zw);
}

vec4 viewSpaceToClipSpace(uvec2 fragCoord)
{
  vec2 texCoord = fragCoordToUV(fragCoord);
  float depth = texture(depthTexture, texCoord);
  vec4 homogenous_view_pos = vec4(fragCoord, depth, 1.0);
  // We need this to be in [-1, 1]:
  homogenous_view_pos = homogenous_view_pos*2.0-1.0;

  vec4 hvolpos = inv_vp*homogenous_view_pos;
  return (hvolpos/hvolpos.w);
}

float linearizeDepth(float depth)
{
    float z = depth * 2.0 - 1.0; // back to NDC
    return (2.0 * near * far) / (far + near - z * (far - near));
}

vec4 CalcEyeFromWindow(in vec3 windowSpace)
{
	vec3 ndcPos;
	ndcPos.xy = ((2.0 * windowSpace.xy) - (2.0 * viewport.xy)) / (viewport.zw) - 1;
	ndcPos.z = (2.0 * windowSpace.z - depthrange.x - depthrange.y) /
    (depthrange.y - depthrange.x);

	vec4 clipPos;
	clipPos.w = persMatrix[3][2] / (ndcPos.z - (persMatrix[2][2] / persMatrix[2][3]));
	clipPos.xyz = ndcPos * clipPos.w;

	return invPersMatrix * clipPos;
}


// Normalized Device Coordinates (Clip Space coordinates) [-1,1] to screen position [0,1]
vec2 ndcToScreenPos(vec2 ndc)
{
  return (ndc*0.5+0.5);
}


//=============== CLOUD UTILITIES ===============//

// Cloud types height density gradients
#define STRATUS_GRADIENT vec4(0.0, 0.1, 0.2, 0.3)
#define STRATOCUMULUS_GRADIENT vec4(0.02, 0.2, 0.48, 0.625)
#define CUMULUS_GRADIENT vec4(0.00, 0.1625, 0.88, 0.98)

#define SUN_DIR light_direction

uniform vec3 cloudColorTop = (vec3(169., 149., 149.)*(1.5/255.));
uniform vec3 cloudColorBottom =  (vec3(65., 70., 80.)*(1.5/255.));
uniform float coverage_multiplier = 0.4;

#define CLOUDS_AMBIENT_COLOR_TOP cloudColorTop
#define CLOUDS_AMBIENT_COLOR_BOTTOM cloudColorBottom

#define CLOUDS_MIN_TRANSMITTANCE 1e-1
#define CLOUDS_TRANSMITTANCE_THRESHOLD 1.0 - CLOUDS_MIN_TRANSMITTANCE

float getHeightFractionForPoint(vec3 position)
{
  // Get global fractional position in cloud zone
  float cloudMinHeight = AABBmin.y;
  float cloudMaxHeight = AABBmax.y;
  float height_fraction = (position.y-cloudMinHeight)/(cloudMaxHeight - cloudMinHeight);
  return clamp(height_fraction, 0.0, 1.0);
}

float getDensityForCloud(float heightFraction, float cloudType)
{
	float stratusFactor = 1.0 - clamp(cloudType * 2.0, 0.0, 1.0);
	float stratoCumulusFactor = 1.0 - abs(cloudType - 0.5) * 2.0;
	float cumulusFactor = clamp(cloudType - 0.5, 0.0, 1.0) * 2.0;

	vec4 baseGradient = stratusFactor * STRATUS_GRADIENT + stratoCumulusFactor * STRATOCUMULUS_GRADIENT + cumulusFactor * CUMULUS_GRADIENT;
	// gradicent computation (see Siggraph 2017 Nubis-Decima talk)
	//return remap(heightFraction, baseGradient.x, baseGradient.y, 0.0, 1.0) * remap(heightFraction, baseGradient.z, baseGradient.w, 1.0, 0.0);
	return smoothstep(baseGradient.x, baseGradient.y, heightFraction) - smoothstep(baseGradient.z, baseGradient.w, heightFraction);

}

/*
1. The first step is to retrieve the four low-frequency noise values required
   to build a basic cloud shape. We sample the first 3D texture, containing
   low-frequency octaves.
2. We will use the first channel, which contains the Perlin-Worley noise, to
   establish our base cloud shape.
3. Though the basic Perlin-Worley noise provides a reasonable cloud density
   function, it lacks the detail of a realistic cloud. We use a remapping function
   to add the three other low-frequency noises to the edges of the Perlin-Worley
   noise. This method of combining noises prevents the interior of the Perlin-
   Worley cloud shape from becoming non-homogenous and also ensures that
   we only add detail in the areas that we can see.
4. To determine the type of cloud we are drawing, we compute our density
   height function based on the cloud type attribute from our weather texture.
5. Next, we multiply the base cloud shape by the density height function to
   create the correct type of cloud according to the weather data.

*/

float sampleCloudDensity(vec3 rayPos, int lod)
{
  vec3 uvw = uvwFromWorldPos(rayPos);
  float height_fraction = getHeightFractionForPoint(rayPos); 

  // Original sample had low frequency noise as a 32x32x32 texture
  // int level_of_detail = int(texture_size.x/32);
  // int lod = 128/32;

  // We read the low-frequency Perlin-Worley and Worley noises
  vec4 low_frequency_noises = textureLod(perlinWorley, uvw, 6); 

  // Build FBM out of the low frequency noises:
  float low_freq_fbm = (low_frequency_noises.g * 0.625)
                       + (low_frequency_noises.b * 0.25)
                       + (low_frequency_noises.a * 0.125);
  // Define the base cloud shape by dilating it with the low-frequency FBM made of worley noise:
  float base_cloud = remap(low_frequency_noises.r, -(1.0-low_freq_fbm), 1.0, 0.0, 1.0);

  // Remember! Cloud coverage is stored in weather's red channel:
  vec4 weather_data = textureLod(weather, uvw.xz, 4); // We use uvw.xz because we want weather to be applied in horizontal xz plane

  // float density = 
	float density_height_gradient = getDensityForCloud(height_fraction, 0.5);
	// base_cloud *= (density/height_fraction);
  // base_cloud *= density;
  // float cloud_height = pow(weather_data.r, 0.75);
  float cloud_height = pow(low_frequency_noises.r, 0.75);
  // base_cloud *= clamp(remap(height_fraction, 0.0, 0.175, 0.25, 1.0), 0.0, 1.0);
  // base_cloud *= clamp(remap(height_fraction, 0.75*cloud_height, cloud_height, 1.0, 0.0), 0.0, 1.0);
  // base_cloud *= density_height_gradient;
  base_cloud *= density_height_gradient;
  
  float cloud_coverage = weather_data.r*coverage_multiplier;
  float base_cloud_with_coverage = remap(base_cloud, cloud_coverage, 1.0, 0.0, 1.0);
  base_cloud_with_coverage *= cloud_coverage;

	// return clamp(base_cloud_with_coverage, 0.0, 1.0);
  // if (expensive)
  vec3 high_frequency_noises = textureLod(perlinWorley, uvw, 0).gba; // Only get worley parts
  float high_freq_fbm = (high_frequency_noises[0]*0.625)
                        + (high_frequency_noises[1] * 0.25)
                        + (high_frequency_noises[2] * 0.125);
  

  // Transition from wispy shapes to billowy shapes over height
  float high_freq_noise_modifier = mix(high_freq_fbm, 1.0-high_freq_fbm, clamp(height_fraction*10.0, 0.0, 1.0));

  // Erode the base cloud shape with the distorted high-frequency worley noises
  // base_cloud_with_coverage = base_cloud_with_coverage - high_freq_noise_modifier * (1.0 - base_cloud_with_coverage);

  base_cloud_with_coverage = remap(base_cloud_with_coverage*2.0, high_freq_noise_modifier * 0.2, 1.0, 0.0, 1.0);
  return base_cloud_with_coverage;
  // float final_cloud = remap(base_cloud_with_coverage, high_freq_noise_modifier*0.2, 1.0, 0.0, 1.0);
  // return final_cloud;
}

uniform float density_factor = 0.02;
// vec4 raymarchCloud(vec3 startPos, vec3 endPos)
// {
//   vec3 path = endPos-startPos;
//   float len = length(path);

//   const int nSteps = 64;

//   float ds = len/nSteps;
//   vec3 dir = path/len;
//   vec4 col = vec4(1.0);
//   vec3 path_segment = dir*ds;

//   vec3 pos = startPos;
// 	// uvec2 fragCoord = gl_GlobalInvocationID.xy;
// 	// int a = int(fragCoord.x) % 4;
// 	// int b = int(fragCoord.y) % 4;
// 	// startPos += dir * bayerFilter[a * 4 + b];
//   float density = 0.0;

//   float lightDotEye = dot(normalize(SUN_DIR), normalize(dir));

//   float T = 1.0;
//   float sigma_ds = -ds*densityFactor;

//   for (int i = 0; i < nSteps; i++)
//   {
//     float density_sample = sampleCloudDensity(pos, i/16);
//     if (density_sample > 0.0)
//     {
//       float height = getHeightFractionForPoint(pos);
//       vec3 ambientLight = CLOUDS_AMBIENT_COLOR_BOTTOM;
//       // float light_density = raymarchToLight(pos, ds*0.1, SUN_DIR, sensity_sample, lightDotEye);
      
//       float dTrans = exp(density_sample*sigma_ds);
//       T *= dTrans;
//     }
//     if (T <= CLOUDS_MIN_TRANSMITTANCE) break;
//     pos  += path_segment;
//   }

//   col.a = 1.0-T;
//   return col;
// }

vec4 raymarchCloud(Ray r, float tnear, float tfar, float obstacle_clip_pos)
{

  // vec4 obstacle_clip_pos = texture(depth, ray_origin_ndc.xy);

  // vec4 obstacle_world_pos = inv_vp*vec4(obstacle_clip_pos.xy, (obstacle_clip_pos-0.1)/350.0, 1.0);
  // vec4 obstacle_world_pos = vec4(1.0);
  // // vec4 depth_world = inv_vp*vec4(ray_origin_ndc.xy, obstacle_clip_pos.z/255.0, 1.0);
  // vec4 obstacle_world_pos = inv_view*obstacle_clip_pos;
  // obstacle_world_pos.z = obstacle_clip_pos.z;
  // obstable_world_pos = inv_proj*obstacle_world_pos;
  // obstacle_world_pos = obstacle_world_pos/obstacle_world_pos.w;

  vec4 dst = vec4(vec3(1.0), 0.0);
  vec3 rayPos = r.origin + r.dir*tnear;
  for (int i = 0; i < STEPS_PRIMARY; i++)
  {

    float density_sample = sampleCloudDensity(rayPos, 0);

    // Front-to-back compositing
    dst.a += (1.0-dst.a)*density_sample*0.2;

    if (!isInsideAABB(rayPos)) break;
    // if (obstacle_clip_pos > (vp*vec4(rayPos, 1.0)).z) break;
    rayPos += r.dir*StepSize;
  }
  return dst;
}


void main()
{
  ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);
  ivec2 size = imageSize(OutputFrag);

  // if (fragCoord.x > size.x || fragCoord.y > size.y) return;
  if (fragCoord.x > viewport.z || fragCoord.y > viewport.w) return;
  Ray r;

  // Create ray origin and direction
  // Transfer from screen space -> clip space -> world space 

  // The ray is at clipspace coords x,y and shoots a ray into the scene, (i.e. z=1)
  vec4 ray_dir_ndc = vec4(fragToClipSpace(fragCoord).xy, 1.0 , 1.0);
  vec4 ray_dir_view = inv_proj*ray_dir_ndc;

  // I don't know why this works, but it does
  ray_dir_view = vec4(ray_dir_view.xy, -1.0, 0.0);
  vec4 ray_dir_world = (inv_view*ray_dir_view);

  // Doing it like this makes it a bit distorted
  // vec4 ray_dir_world = inv_vp*ray_dir_ndc;
  // ray_dir_world = ray_dir_world/ray_dir_world.w;

  // The same for ray origin, only that this time the coordinate starts at the near plane, i.e. z=-1
  vec4 ray_origin_ndc = vec4(fragToClipSpace(fragCoord), 1.0);
  vec4 ray_origin_world = inv_vp*ray_origin_ndc;
  ray_origin_world = ray_origin_world/ray_origin_world.w;

  // From https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays
  // Doesn't work, though!
  // vec4 rayPWorld = inv_vp*vec4(fragToClipSpace(fragCoord), 1.0);
  // r.dir = normalize((rayPWorld/rayPWorld.w - ray_origin_world).xyz);


  r.origin = ray_origin_world.xyz;
  r.dir = normalize(ray_dir_world.xyz);
  // r.cosA = r.dir.z;
  float tnear, tfar;
  bool hit = RayAABBIntersection(r, AABBmin, AABBmax, tnear, tfar);

  vec4 dst = vec4(vec3(1.0),0.0);
  // dst.a = 1.0;
  // // float n = 0.1;
  // // float f = 350.0;
  vec4 depthSample = texture(depth, fragCoord/viewport.zw);
  float linearDepth = linearizeDepth(depthSample.r);

  if (hit)
  {
    float t = tnear;
    vec3 rayPos = r.origin + r.dir*tnear;
    for (int i = 0; i < STEPS_PRIMARY; i++)
    {

      float density_sample = sampleCloudDensity(rayPos, 0);

      // Front-to-back compositing
      dst.a += (1.0-dst.a)*density_sample*0.2;
      vec4 ray_pos_ndc = vp*vec4(rayPos, 1.0);
      ray_pos_ndc /= ray_pos_ndc.w;
      // if (z < (vp*vec4(rayPos, 1.0)).z) break;
      // rayPos += r.dir*StepSize;
      // t += StepSize;
      // rayPos = r.origin + r.dir*t;
      // vec3 ray_ndc = ray_origin_ndc.xyz + normalize(ray_dir_ndc.xyz)*t;
      // if (ray_ndc.z < z) break;

      if (!isInsideAABB(rayPos)) break;

    }

    // dst.a = 1.0;
    // vec4 dst = raymarchCloud(r.origin + r.dir*tnear, r.origin + r.dir*tfar);
    // dst = raymarchCloud(r, tnear, tfar, obstacle_clip_depth);
    // dst.a = 1.0;
  //   float T = 1.0;
  //   // float ds = 
  //   float sigma_ds = -StepSize*densityFactor;
  //   vec3 rayPos = r.origin + r.dir*tnear;
  //   for (int i = 0; i < STEPS_PRIMARY; i++)
  //   {

  //     float density_sample = sampleCloudDensity(rayPos);
  //     // if (density_sample > 0.15)
  //     // {
  //     dst.a += (1.0-dst.a)*density_sample*0.02;
  //     // }
        
  //     if (dst.a > 0.8) break;

  //     if (!isInsideAABB(rayPos)) break;
  //     rayPos += r.dir*StepSize;
  //   }
  //   // dst.a = 1.0-T;
  // }
  // // vec4 weatherValue = vec4(texture(weather, uvwFromWorldPos(r.origin + r.dir*tnear).xy).bbb, 1.0);
  // // imageStore(OutputFrag, fragCoord, weatherValue);
  }
  imageStore(OutputFrag, fragCoord, dst);
}
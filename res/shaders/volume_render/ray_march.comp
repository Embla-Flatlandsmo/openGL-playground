#version 430

layout(binding=0) uniform sampler3D perlinWorley; 
// Weather contains [coverage, cloud type, 0, 1]
layout(binding=1) uniform sampler2D weather;
layout(binding=2) uniform sampler2D depth;

uniform vec3 VolumeGridSize;
uniform vec3 AABBmin;
uniform vec3 AABBmax;

uniform float StepSize;
uniform float time;


uniform mat4 inv_vp;
uniform mat4 inv_view;
uniform mat4 inv_proj;
uniform mat4 proj;
uniform mat4 vp;
uniform vec4 viewport;

uniform vec3 lightColor = vec3(1.0);
uniform vec3 light_direction;
uniform float near = 0.1;
uniform float far = 350.0;


layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba8, binding = 0) uniform image2D OutputFrag;

// #define FAST

#ifdef FAST
	#define STEPS_PRIMARY 16
#else
	#define STEPS_PRIMARY 200
#endif


// Maps a value from one range to another
float remap(float original_value, float original_min, float original_max, float new_min, float new_max)
{
    return (((original_value - original_min) / (original_max - original_min)) * (new_max - new_min)) + new_min;
}

struct Ray {
  vec3 origin;
  vec3 dir;
  // float cosA;
};
//=============== COORDINATE UTILITIES ===============//

bool IntersectBox (Ray r, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar)
{
  vec3 invR = vec3(1.0) / r.dir;
  
  vec3 tbbmin = invR * (boxmin - r.origin);
  vec3 tbbmax = invR * (boxmax - r.origin);
   
  vec3 tmin = min(tbbmin, tbbmax);
  vec3 tmax = max(tbbmin, tbbmax);
  
  tnear = max(max(tmin.x, tmin.y), tmin.z);
  tfar  = min(min(tmax.x, tmax.y), tmax.z);

  return tfar > tnear;
}

bool RayAABBIntersection (Ray r, vec3 bbmin, vec3 bbmax, 
                          out float rtnear, out float rtfar)
{
 
  float tnear, tfar;
  bool hit = IntersectBox(r, bbmin, bbmax, tnear, tfar);

  tnear = max(tnear, 0.0);

  rtnear = tnear;
  rtfar  = tfar;

  return hit;
}

vec3 uvwFromWorldPos(vec3 pos)
{
  vec3 bbsize = AABBmax-AABBmin;

  // Bring pos to world origin
  vec3 centered_pos = pos-AABBmin;

  // Divide by bbsize to get coordinates on [0,1]
  return mod(centered_pos/bbsize, vec3(1.0));
  // return clamp(centered_pos/bbsize, vec3(0.0), vec3(1.0));
}


// Finds fragment coordinate fragCoord.x = [0,1920], fragCoord.y=[0,1080]
// and converts it to normalized device coordinates [-1, 1]
vec3 fragToClipSpace(uvec2 fragCoord)
{
  vec2 ndc = 2.0*vec2(fragCoord.xy-viewport.xy)/viewport.zw - 1.0;
  return vec3(ndc, -1.0);
}

vec2 fragCoordToUV(uvec2 fragCoord)
{
  return vec2(fragCoord)/(viewport.zw);
}

// https://mynameismjp.wordpress.com/2009/03/10/reconstructing-position-from-depth/
// Function for converting depth to view-space position
// in deferred pixel shader pass.  vTexCoord is a texture
// coordinate for a full-screen quad, such that x=0 is the
// left of the screen, and y=0 is the top of the screen.
vec3 VSPositionFromDepth(vec2 vTexCoord)
{
    // Get the depth value for this pixel
    float z = texture(depth, vTexCoord).r;  
    // Get x/w and y/w from the viewport position
    float x = vTexCoord.x * 2 - 1;
    // float y = (1 - vTexCoord.y) * 2 - 1;
    float y = vTexCoord.y*2-1;
    vec4 vProjectedPos = vec4(x, y, z, 1.0f);
    // Transform by the inverse projection matrix
    vec4 vPositionVS = inv_proj*vProjectedPos;  
    // Divide by w to get the view-space position
    return vPositionVS.xyz / vPositionVS.w;  
}


// Normalized Device Coordinates (Clip Space coordinates) [-1,1] to screen position [0,1]
vec2 ndcToScreenPos(vec2 ndc)
{
  return (ndc*0.5+0.5);
}


//=============== CLOUD UTILITIES ===============//

// Cloud types height density gradients
#define STRATUS_GRADIENT vec4(0.0, 0.1, 0.2, 0.3)
#define STRATOCUMULUS_GRADIENT vec4(0.02, 0.2, 0.48, 0.625)
#define CUMULUS_GRADIENT vec4(0.00, 0.1625, 0.88, 0.98)

#define SUN_DIR light_direction

uniform vec3 cloudColorTop = (vec3(169., 149., 149.)*(1.5/255.));
uniform vec3 cloudColorBottom =  (vec3(65., 70., 80.)*(1.5/255.));
uniform float coverage_multiplier = 0.4;
uniform float density_factor = 0.2;

uniform float cloud_speed = 100.8;


#define CLOUDS_AMBIENT_COLOR_TOP cloudColorTop
#define CLOUDS_AMBIENT_COLOR_BOTTOM cloudColorBottom

#define CLOUDS_MIN_TRANSMITTANCE 1e-1
#define CLOUDS_TRANSMITTANCE_THRESHOLD 1.0 - CLOUDS_MIN_TRANSMITTANCE

float getHeightFractionForPoint(vec3 position)
{
  // Get global fractional position in cloud zone
  float cloudMinHeight = AABBmin.y;
  float cloudMaxHeight = AABBmax.y;
  float height_fraction = (position.y-cloudMinHeight)/(cloudMaxHeight - cloudMinHeight);
  return clamp(height_fraction, 0.0, 1.0);
}

float getDensityForCloud(float heightFraction, float cloudType)
{
	float stratusFactor = 1.0 - clamp(cloudType * 2.0, 0.0, 1.0);
	float stratoCumulusFactor = 1.0 - abs(cloudType - 0.5) * 2.0;
	float cumulusFactor = clamp(cloudType - 0.5, 0.0, 1.0) * 2.0;

	vec4 baseGradient = stratusFactor * STRATUS_GRADIENT + stratoCumulusFactor * STRATOCUMULUS_GRADIENT + cumulusFactor * CUMULUS_GRADIENT;
	// gradicent computation (see Siggraph 2017 Nubis-Decima talk)
	//return remap(heightFraction, baseGradient.x, baseGradient.y, 0.0, 1.0) * remap(heightFraction, baseGradient.z, baseGradient.w, 1.0, 0.0);
	return smoothstep(baseGradient.x, baseGradient.y, heightFraction) - smoothstep(baseGradient.z, baseGradient.w, heightFraction);

}

/*
1. The first step is to retrieve the four low-frequency noise values required
   to build a basic cloud shape. We sample the first 3D texture, containing
   low-frequency octaves.
2. We will use the first channel, which contains the Perlin-Worley noise, to
   establish our base cloud shape.
3. Though the basic Perlin-Worley noise provides a reasonable cloud density
   function, it lacks the detail of a realistic cloud. We use a remapping function
   to add the three other low-frequency noises to the edges of the Perlin-Worley
   noise. This method of combining noises prevents the interior of the Perlin-
   Worley cloud shape from becoming non-homogenous and also ensures that
   we only add detail in the areas that we can see.
4. To determine the type of cloud we are drawing, we compute our density
   height function based on the cloud type attribute from our weather texture.
5. Next, we multiply the base cloud shape by the density height function to
   create the correct type of cloud according to the weather data.

*/

#define CLOUD_TOP_OFFSET 20.0
const vec3 windDirection = normalize(vec3(0.5, 0.0, 0.1));
float sampleCloudDensity(vec3 rayPos, int lod)
{
  vec3 uvw = uvwFromWorldPos(rayPos);
  float height_fraction = getHeightFractionForPoint(rayPos); 
	// vec3 animation = height_fraction * windDirection * CLOUD_TOP_OFFSET + windDirection * time * cloud_speed;
  vec3 animation = height_fraction*windDirection*CLOUD_TOP_OFFSET + windDirection*time*cloud_speed;
  vec3 moving_uvw = uvwFromWorldPos(rayPos+animation);
  // Original sample had low frequency noise as a 32x32x32 texture
  // int level_of_detail = int(texture_size.x/32);
  // int lod = 128/32;

  // We read the low-frequency Perlin-Worley and Worley noises
  vec4 low_frequency_noises = textureLod(perlinWorley, uvw, 6); 

  // Build FBM out of the low frequency noises:
  float low_freq_fbm = (low_frequency_noises.g * 0.625)
                       + (low_frequency_noises.b * 0.25)
                       + (low_frequency_noises.a * 0.125);
  // Define the base cloud shape by dilating it with the low-frequency FBM made of worley noise:
  float base_cloud = remap(low_frequency_noises.r, -(1.0-low_freq_fbm), 1.0, 0.0, 1.0);

  // Remember! Cloud coverage is stored in weather's red channel:
  vec4 weather_data = textureLod(weather, moving_uvw.xz, 4); // We use uvw.xz because we want weather to be applied in horizontal xz plane

  // float density = 
	float density_height_gradient = getDensityForCloud(height_fraction, 0.5);
	// base_cloud *= (density/height_fraction);
  // base_cloud *= density;
  // float cloud_height = pow(weather_data.r, 0.75);
  float cloud_height = pow(low_frequency_noises.r, 0.75);
  // base_cloud *= clamp(remap(height_fraction, 0.0, 0.175, 0.25, 1.0), 0.0, 1.0);
  // base_cloud *= clamp(remap(height_fraction, 0.75*cloud_height, cloud_height, 1.0, 0.0), 0.0, 1.0);
  // base_cloud *= density_height_gradient;
  base_cloud *= density_height_gradient;
  
  float cloud_coverage = weather_data.r*coverage_multiplier;
  float base_cloud_with_coverage = remap(base_cloud, cloud_coverage, 1.0, 0.0, 1.0);
  base_cloud_with_coverage *= cloud_coverage;

	// return clamp(base_cloud_with_coverage, 0.0, 1.0);
  // if (expensive)
  vec3 high_frequency_noises = textureLod(perlinWorley, uvw, 0).gba; // Only get worley parts
  float high_freq_fbm = (high_frequency_noises[0]*0.625)
                        + (high_frequency_noises[1] * 0.25)
                        + (high_frequency_noises[2] * 0.125);
  

  // Transition from wispy shapes to billowy shapes over height
  float high_freq_noise_modifier = mix(high_freq_fbm, 1.0-high_freq_fbm, clamp(height_fraction*10.0, 0.0, 1.0));

  // Erode the base cloud shape with the distorted high-frequency worley noises
  // base_cloud_with_coverage = base_cloud_with_coverage - high_freq_noise_modifier * (1.0 - base_cloud_with_coverage);

  base_cloud_with_coverage = remap(base_cloud_with_coverage*2.0, high_freq_noise_modifier * 0.2, 1.0, 0.0, 1.0);
  return base_cloud_with_coverage;
  // float final_cloud = remap(base_cloud_with_coverage, high_freq_noise_modifier*0.2, 1.0, 0.0, 1.0);
  // return final_cloud;
}

vec4 raymarchCloud(Ray ray_world, Ray ray_viewspace, float tnear, float tfar, vec3 view_space_obstacle)
{
 
  vec4 dst = vec4(vec3(1.0),0.0);
  float t = tnear;
  vec3 rayPos = ray_world.origin + ray_world.dir*tnear;
  for (int i = 0; i < STEPS_PRIMARY; i++)
  {
    float density_sample = sampleCloudDensity(rayPos, i/40);

    // Front-to-back compositing
    dst.a += (1.0-dst.a)*density_sample*density_factor;
    vec3 ray_viewspace_position = ray_viewspace.origin + ray_viewspace.dir*t;
    if (t > tfar) break;
    if (ray_viewspace_position.z < view_space_obstacle.z) break; // TODO: Figure out how to integrate until exact t value
    t += StepSize;
    rayPos = ray_world.origin + ray_world.dir*t;
  }
  return dst;
}


void main()
{
  ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);
  ivec2 size = imageSize(OutputFrag);
  if (fragCoord.x > viewport.z || fragCoord.y > viewport.w) return;

  Ray ray_viewspace;
  // Create ray origin and direction
  // Transfer from screen space -> clip space -> world space 
  // The ray is at clipspace coords x,y and shoots a ray into the scene, (i.e. z=1)
  vec4 ray_dir_ndc = vec4(fragToClipSpace(fragCoord).xy, 1.0 , 1.0);
  vec4 ray_dir_view = inv_proj*ray_dir_ndc;

  // I don't know why this works, but it does
  ray_dir_view = vec4(ray_dir_view.xy, -1.0, 0.0);
  vec4 ray_dir_world = (inv_view*ray_dir_view);

  // The same for ray origin, only that this time the coordinate starts at the near plane, i.e. z=-1
  vec4 ray_origin_ndc = vec4(fragToClipSpace(fragCoord), 1.0);
  vec4 ray_origin_view = inv_proj*ray_origin_ndc;
  ray_origin_view /= ray_origin_view.w; 
  vec4 ray_origin_world = inv_view*ray_origin_view;


  Ray ray_world;
  ray_world.origin = ray_origin_world.xyz;
  ray_world.dir = normalize(ray_dir_world.xyz);

  ray_viewspace.origin = ray_origin_view.xyz;
  ray_viewspace.dir = normalize(ray_dir_view.xyz);
  float tnear, tfar;
  bool hit = RayAABBIntersection(ray_world, AABBmin, AABBmax, tnear, tfar);

  // Boid position (if there is one) in view space:
  vec3 view_space_obstacle = VSPositionFromDepth(fragCoordToUV(fragCoord));

  vec4 dst = vec4(vec3(1.0),0.0);
  if (hit)
  {
    dst = raymarchCloud(ray_world, ray_viewspace, tnear, tfar, view_space_obstacle);
  }
  imageStore(OutputFrag, fragCoord, dst);
}
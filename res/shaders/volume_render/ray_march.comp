#version 430

uniform sampler3D perlin; 
// layout (binding = 2) uniform sampler1D TexTransferFunc;
// layout (binding = 3) uniform sampler3D TexVolumeGradient;

// uniform vec3 VolumeGridResolution;
// uniform vec3 VolumeVoxelSize;
uniform vec3 VolumeGridSize;
uniform vec3 AABBmin;
uniform vec3 AABBmax;

uniform vec3 CameraEye; // Cam pos

uniform mat4 u_CameraLookAt; // View matrix
uniform mat4 ProjectionMatrix;

uniform float u_TanCameraFovY;
uniform float u_CameraAspectRatio;

uniform float StepSize;

// uniform vec3 VolumeScales;

// uniform int ApplyGradientPhongShading;

// uniform vec3 WorldEyePos;
// uniform vec3 LightSourcePosition;

// uniform int ApplyOcclusion;
// uniform int ApplyShadow;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba16f, binding = 0) uniform image2D OutputFrag;

//////////////////////////////////////////////////////////////////////////////////////////////////
// From _structured_volume_data/ray_bbox_intersection.frag
struct Ray { vec3 Origin; vec3 Dir; };
// bool RayAABBIntersection (vec3 vert_eye, vec3 vert_dir, vec3 vol_scaled_dim,
//                           out Ray r, out float rtnear, out float rtfar);

bool IntersectBox (Ray r, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar)
{
  vec3 invR = vec3(1.0) / r.Dir;
  
  vec3 tbbmin = invR * (boxmin - r.Origin);
  vec3 tbbmax = invR * (boxmax - r.Origin);
   
  vec3 tmin = min(tbbmin, tbbmax);
  vec3 tmax = max(tbbmin, tbbmax);
  
  tnear = max(max(tmin.x, tmin.y), tmin.z);
  tfar  = min(min(tmax.x, tmax.y), tmax.z);

  return tfar > tnear;
}

bool RayAABBIntersection (vec3 vert_eye, vec3 vert_dir, vec3 vol_scaled_dim,
                          out Ray r, out float rtnear, out float rtfar)
{
  // vec3 aabbmin = -vol_scaled_dim * 0.5;
  // vec3 aabbmax =  vol_scaled_dim * 0.5;

  r.Origin = vert_eye;
  r.Dir = normalize(vert_dir);
  
  float tnear, tfar;
  bool hit = IntersectBox(r, AABBmin, AABBmax, tnear, tfar);

  tnear = max(tnear, 0.0);

  rtnear = tnear;
  rtfar  = tfar;

  return hit;
}

//////////////////////////////////////////////////////////////////////////////////////////////////

vec4 sampleDensity(vec3 rayPos)
{
  vec3 bbsize = AABBmax-AABBmin;
  // Bring rayPos to world origin
  vec3 centeredRayPos = rayPos-AABBmin;
  // Divide by bbsize to get coordinates on [0,1]
  vec3 uvw = centeredRayPos/bbsize;
  // uvw[2] = 0;
  return texture(perlin, uvw);
  // vec3 uvw = (size*0.5 + rayPos);
}

// vec3 computeClipSpaceCoord(uvec2 fragCoord){
// 	vec2 ray_nds = 2.0*vec2(fragCoord.xy)/iResolution.xy - 1.0;
// 	return vec3(ray_nds, 1.0);
// }

// vec2 computeScreenPos(vec2 ndc){
// 	return (ndc*0.5 + 0.5);
// }

//#define USE_TRANSPARENCY
//#define USE_TRANSPARENCY_DS
void main ()
{
  ivec2 storePos = ivec2(gl_GlobalInvocationID.xy);
  ivec2 pixelCoord = ivec2(gl_GlobalInvocationID.xy);
  
  ivec2 size = imageSize(OutputFrag);
  if (pixelCoord.x < size.x && pixelCoord.y < size.y)
  {

    // vec4 ray_clip = vec4(computeClipSpaceCoord(fragCoord), 1.0);
    // vec4 ray_view = inv_proj * ray_clip;
    // ray_view = vec4(ray_view.xy, -1.0, 0.0);
    // vec3 worldDir = (inv_view * ray_view).xyz;
    // worldDir = normalize(worldDir);
    // Get screen position [x, y] and consider centering the pixel by + 0.5
    vec2 fpos = vec2(storePos) + 0.5;

    // Transform fpos from [w, h] to [0, 1] to [-1, 1]
    vec3 VerPos = (vec3(fpos.x / float(size.x), fpos.y / float(size.y), 0.0) * 2.0) - 1.0;

    // Camera direction
    vec3 camera_dir = normalize(vec3(VerPos.x * u_TanCameraFovY * u_CameraAspectRatio, VerPos.y * u_TanCameraFovY, -1.0) * mat3(u_CameraLookAt));
    // Find Ray Intersection
    Ray r; float tnear, tfar;
    bool inbox = RayAABBIntersection(CameraEye, camera_dir, VolumeGridSize, r, tnear, tfar);

    // If inside volume grid
    vec4 dst = vec4(vec3(1.0),0.0);
    if(inbox)
    {
      // Distance to be evaluated
      float D = abs(tfar - tnear);
      vec3 rayPos = r.Origin + r.Dir*tnear;
      for (int i = 0; i < 200; i++) 
      {
        vec4 val = sampleDensity(rayPos);
        // float scalar = (val.r+val.g+val.b)/3.0;
        float scalar = val.r;
        if (val.r > 0.85)
          dst.a += (1.0-dst.a)*scalar*0.1;
        
        // dst.a += (1.0-dst.a)*scalar*0.1;
        if (dst.a > 0.5) break;
        if (rayPos.x > AABBmax.x || rayPos.y > AABBmax.y || rayPos.z > AABBmax.z) break;
        rayPos += r.Dir*StepSize;
      }

      // // Initialize Transparency and Radiance color
      // // #ifdef USE_TRANSPARENCY
      // //       vec4 dst = vec4(vec3(0.0),1.0);
      // // #else
      // //       vec4 dst = vec4(0.0);
      // // #endif
      // // World position at tnear, translated to the volume [0, VolumeGridSize]
      // vec3 wld_pos = r.Origin + r.Dir * tnear;
      // // Texture position
      // // vec3 tex_pos = wld_pos + (VolumeGridSize * 0.5);
      // vec3 tex_pos = wld_pos + (VolumeGridSize * 0.5);

      // // Evaluate from 0 to D...
      // for(float s = 0.0; s < D;)
      // {
      //   // Get the current step or the remaining interval
      //   float h = min(StepSize, D - s);
      
      //   // Texture position at tnear + (s + h/2)
      //   vec3 s_tex_pos = tex_pos  + r.Dir * (s + h * 0.5);
      
      //   // Get normalized density from volume
      //   // float density = texture(perlin, s_tex_pos / VolumeGridSize).r;
        
      //   // // Get color from transfer function given the normalized density
      //   // vec4 src = 
      //   //   //vec4(density)
      //   //   texture(TexTransferFunc, density)
      //   // ;
       
      //   // if sample is non-transparent
      //   vec4 src = texture(perlin, s_tex_pos/VolumeGridSize);
      //   // vec4 src = vec4(1.0);
      //   if(src.a > 0.0)
      //   {
      //     float scalar = (src.r+src.g+src.b)/3.0;
      //     // float scalar = vec4(1.0);
      //     // float scalar = src.r;
      //     // float scalar = 0.1;
      //     dst.a += (1.0-dst.a)*scalar;
      // // #ifdef USE_TRANSPARENCY
      // //   #ifdef USE_TRANSPARENCY_DS
      // //           dst.rgb = dst.rgb + dst.a * src.a * src.rgb * h;
      // //           dst.a = dst.a * exp(-src.a * h);
      // //   #else
      // //           float F = exp(-src.a * h);
      // //           dst.rgb = dst.rgb + dst.a * src.rgb * (1.0 - F);
      // //           dst.a = dst.a * F;
      // //   #endif
      // //           if ((1.0 - dst.a) > 0.99) break;
      // // #else
      // //           // Evaluate the current opacity
      // //           src.a = 1.0 - exp(-src.a * h);
                
      // //           // Front-to-back composition
      // //           src.rgb = src.rgb * src.a;
      // //           dst = dst + (1.0 - dst.a) * src;
          
      //     // Opacity threshold: 99%
      //     if (dst.a > 0.99) break;
      //   }
      //   // Go to the next interval
      //   s = s + h;
      // }
// #ifdef USE_TRANSPARENCY
//       dst.a = 1.0 - dst.a;
// #endif

    }
    imageStore(OutputFrag, storePos, dst);
  }
}
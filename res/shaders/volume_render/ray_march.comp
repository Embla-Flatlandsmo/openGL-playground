#version 430

uniform sampler3D perlin; 
// layout (binding = 2) uniform sampler1D TexTransferFunc;
// layout (binding = 3) uniform sampler3D TexVolumeGradient;

uniform vec3 VolumeGridSize;
uniform vec3 AABBmin;
uniform vec3 AABBmax;

uniform float StepSize;

uniform mat4 inv_vp;
uniform mat4 inv_view;
uniform mat4 inv_proj;
uniform vec4 viewport;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba16f, binding = 0) uniform image2D OutputFrag;

struct Ray { vec3 Origin; vec3 Dir; };

bool IntersectBox (Ray r, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar)
{
  vec3 invR = vec3(1.0) / r.Dir;
  
  vec3 tbbmin = invR * (boxmin - r.Origin);
  vec3 tbbmax = invR * (boxmax - r.Origin);
   
  vec3 tmin = min(tbbmin, tbbmax);
  vec3 tmax = max(tbbmin, tbbmax);
  
  tnear = max(max(tmin.x, tmin.y), tmin.z);
  tfar  = min(min(tmax.x, tmax.y), tmax.z);

  return tfar > tnear;
}

bool RayAABBIntersection (Ray r, vec3 bbmin, vec3 bbmax, 
                          out float rtnear, out float rtfar)
{
 
  float tnear, tfar;
  bool hit = IntersectBox(r, bbmin, bbmax, tnear, tfar);

  tnear = max(tnear, 0.0);

  rtnear = tnear;
  rtfar  = tfar;

  return hit;
}

vec4 sampleDensity(vec3 rayPos)
{
  vec3 bbsize = AABBmax-AABBmin;
  // Bring rayPos to world origin
  vec3 centeredRayPos = rayPos-AABBmin;
  // Divide by bbsize to get coordinates on [0,1]
  vec3 uvw = centeredRayPos/bbsize;
  // uvw[2] = 0;
  return texture(perlin, uvw);
  // vec3 uvw = (size*0.5 + rayPos);
}

// Finds fragment coordinate fragCoord.x = [0,1920], fragCoord.y=[0,1080]
// and converts it to normalized device coordinates [-1, 1]
vec3 fragToClipSpace(uvec2 fragCoord)
{
  vec2 ndc = 2.0*vec2(fragCoord.xy-viewport.xy)/viewport.zw - 1.0;
  return vec3(ndc, -1.0);
}

// Normalized Device Coordinates (Clip Space coordinates) [-1,1] to screen position [0,1]
vec2 ndcToScreenPos(vec2 ndc)
{
  return (ndc*0.5+0.5);
}

void main()
{
  ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy); // 1920x1080
  ivec2 size = imageSize(OutputFrag);

  if (fragCoord.x > size.x || fragCoord.y > size.y) return;

  Ray r;

  // Create ray origin and direction
  // Transfer from screen space -> clip space -> world space 

  // The ray is at clipspace coords x,y and shoots a ray into the scene, (i.e. z=1)
  vec4 ray_dir_ndc = vec4(fragToClipSpace(fragCoord).xy, 1.0 , 1.0);
  vec4 ray_dir_view = inv_proj*ray_dir_ndc;

  // I don't know why this works, but it does
  ray_dir_view = vec4(ray_dir_view.xy, -1.0, 0.0);
  vec4 ray_dir_world = (inv_view*ray_dir_view);

  // Doing it like this makes it a bit distorted
  // vec4 ray_dir_world = inv_vp*ray_dir_ndc;
  // ray_dir_world = ray_dir_world/ray_dir_world.w;

  // The same for ray origin, only that this time the coordinate starts at the near plane, i.e. z=-1
  vec4 ray_origin_ndc = vec4(fragToClipSpace(fragCoord), 1.0);
  vec4 ray_origin_world = inv_vp*ray_origin_ndc;
  ray_origin_world = ray_origin_world/ray_origin_world.w;

  // From https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays
  // Doesn't work, though!
  // vec4 rayPWorld = inv_vp*vec4(fragToClipSpace(fragCoord), 1.0);
  // r.Dir = normalize((rayPWorld/rayPWorld.w - ray_origin_world).xyz);


  r.Origin = ray_origin_world.xyz;
  r.Dir = normalize(ray_dir_world.xyz);

  float tnear, tfar;
  bool hit = RayAABBIntersection(r, AABBmin, AABBmax, tnear, tfar);

  vec4 dst = vec4(vec3(1.0),0.0);

  if (hit)
  {
    vec3 rayPos = r.Origin + r.Dir*tnear;
    for (int i = 0; i < 200; i++)
    {
      vec4 val = sampleDensity(rayPos);
      float scalar = (val.r+val.g+val.b)/3.0;
      // float scalar = 1.0;
      if (val.r > 0.8)
        dst.a += (1.0-dst.a)*scalar*0.1;


      // dst.a += (1.0-dst.a)*scalar*0.1;
      if (dst.a > 0.8) break;

      if (rayPos.x > AABBmax.x || rayPos.y > AABBmax.y || rayPos.z > AABBmax.z) break;
      if (rayPos.x < AABBmin.x || rayPos.y < AABBmin.y || rayPos.z < AABBmin.z) break;
      rayPos += r.Dir*StepSize;
    }
  }

  imageStore(OutputFrag, fragCoord, dst);
}
#version 430

layout(binding=0) uniform sampler3D perlinWorley; 
// Weather contains [coverage, cloud type, 0, 1]
layout(binding=1) uniform sampler2D weather;
layout(binding=2) uniform sampler2D depth;

uniform vec3 VolumeGridSize;
uniform vec3 AABBmin;
uniform vec3 AABBmax;

uniform float StepSize;
uniform float time;


uniform mat4 inv_vp;
uniform mat4 inv_view;
uniform mat4 inv_proj;
uniform mat4 proj;
uniform mat4 vp;
uniform vec4 viewport;

uniform vec3 lightColor = vec3(1.0);
uniform vec3 light_direction = normalize(vec3(-0.5, -0.5, 0.0));
uniform float near = 0.1;
uniform float far = 350.0;


layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba8, binding = 0) uniform image2D OutputFrag;

// #define FAST

#ifdef FAST
	#define STEPS_PRIMARY 16
#else
	#define STEPS_PRIMARY 200
#endif


// Maps a value from one range to another
float remap(float original_value, float original_min, float original_max, float new_min, float new_max)
{
    return (((original_value - original_min) / (original_max - original_min)) * (new_max - new_min)) + new_min;
}

struct Ray {
  vec3 origin;
  vec3 dir;
  // float cosA;
};
//=============== COORDINATE UTILITIES ===============//

bool IntersectBox (Ray r, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar)
{
  vec3 invR = vec3(1.0) / r.dir;
  
  vec3 tbbmin = invR * (boxmin - r.origin);
  vec3 tbbmax = invR * (boxmax - r.origin);
   
  vec3 tmin = min(tbbmin, tbbmax);
  vec3 tmax = max(tbbmin, tbbmax);
  
  tnear = max(max(tmin.x, tmin.y), tmin.z);
  tfar  = min(min(tmax.x, tmax.y), tmax.z);

  return tfar > tnear;
}

bool RayAABBIntersection (Ray r, vec3 bbmin, vec3 bbmax, 
                          out float rtnear, out float rtfar)
{
 
  float tnear, tfar;
  bool hit = IntersectBox(r, bbmin, bbmax, tnear, tfar);

  tnear = max(tnear, 0.0);

  rtnear = tnear;
  rtfar  = tfar;

  return hit;
}

vec3 uvwFromWorldPos(vec3 pos)
{
  vec3 bbsize = AABBmax-AABBmin;
  float largest_side = max(max(bbsize.x, bbsize.y), bbsize.z);
  // float smallest_side = min(min(bbsize.x, bbsize.y), bbsize.z);
  // Bring pos to world origin
  vec3 centered_pos = pos-AABBmin;

  // Divide by bbsize to get coordinates on [0,1]
  return mod(centered_pos/largest_side, vec3(1.0));
  // return clamp(centered_pos/bbsize, vec3(0.0), vec3(1.0));
}


// Finds fragment coordinate fragCoord.x = [0,1920], fragCoord.y=[0,1080]
// and converts it to normalized device coordinates [-1, 1]
vec3 fragToClipSpace(uvec2 fragCoord)
{
  vec2 ndc = 2.0*vec2(fragCoord.xy-viewport.xy)/viewport.zw - 1.0;
  return vec3(ndc, -1.0);
}

vec2 fragCoordToUV(uvec2 fragCoord)
{
  return vec2(fragCoord)/(viewport.zw);
}

// https://mynameismjp.wordpress.com/2009/03/10/reconstructing-position-from-depth/
// Function for converting depth to view-space position
// in deferred pixel shader pass.  vTexCoord is a texture
// coordinate for a full-screen quad, such that x=0 is the
// left of the screen, and y=0 is the top of the screen.
vec3 VSPositionFromDepth(vec2 vTexCoord)
{
    // Get the depth value for this pixel
    float z = texture(depth, vTexCoord).r;  
    // Get x/w and y/w from the viewport position
    float x = vTexCoord.x * 2 - 1;
    // float y = (1 - vTexCoord.y) * 2 - 1;
    float y = vTexCoord.y*2-1;
    vec4 vProjectedPos = vec4(x, y, z, 1.0f);
    // Transform by the inverse projection matrix
    vec4 vPositionVS = inv_proj*vProjectedPos;  
    // Divide by w to get the view-space position
    return vPositionVS.xyz / vPositionVS.w;  
}


// Normalized Device Coordinates (Clip Space coordinates) [-1,1] to screen position [0,1]
vec2 ndcToScreenPos(vec2 ndc)
{
  return (ndc*0.5+0.5);
}

//=============== LIGHT UTILITIES ===============//
//Scattering and absorption coefficients
const vec3 sigmaS = vec3(1);
const vec3 sigmaA = vec3(0.0);
//Extinction coefficient.
const vec3 sigmaE = max(sigmaS + sigmaA, vec3(1e-6));
uniform float sun_power = 200.0;

/* // Henyey-Greenstein Phase function (GPU Pro 7 Ch 4.4.3)
// g = eccentricity, normally 0.2
float HenyeyGreenstein(vec3 lightVector, vec3 viewVector, float g)
{
  float cos_angle = dot(normalize(lightVector), normalize(viewVector));
  return ((1.0 - g*g) /pow((1.0+g*g-2.0*g*cos_angle), 3.0/2.0)) / 4.0*3.1415;
} */

float HenyeyGreenstein(float g, float costh){
	return (1.0/(4.0 * 3.1415))  * ((1.0 - g * g) / pow(1.0 + g*g - 2.0*g*costh, 1.5));
}

//https://twitter.com/FewesW/status/1364629939568451587/photo/1
vec3 multipleOctaves(float extinction, float mu, float stepL){

    vec3 luminance = vec3(0);
    const float octaves = 4.0;
    
    //Attenuation
    float a = 1.0;
    //Contribution
    float b = 1.0;
    //Phase attenuation
    float c = 1.0;
    
    float phase;
    
    for(float i = 0.0; i < octaves; i++){
        //Two-lobed HG
        phase = mix(HenyeyGreenstein(-0.1*c, mu), HenyeyGreenstein(0.3*c, mu), 0.7);
        luminance += b * phase * exp(-stepL * extinction * sigmaE * a);
        //Lower is brighter
        a *= 0.2;
        //Higher is brighter
        b *= 0.5;
        c *= 0.5;
    }
    return luminance;
}

uniform float absorption = 0.0035;
float powder(float d)
{
	return (1. - exp(-2.*d));
}

//=============== CLOUD UTILITIES ===============//

// Cloud types height density gradients
#define STRATUS_GRADIENT vec4(0.0, 0.1, 0.2, 0.3)
#define STRATOCUMULUS_GRADIENT vec4(0.02, 0.2, 0.48, 0.625)
#define CUMULUS_GRADIENT vec4(0.00, 0.1625, 0.88, 0.98)

uniform vec3 light_color = vec3(1.0);

#define SUN_DIR light_direction
#define SUN_COLOR light_color*vec3(1.1, 1.1, 0.95)


uniform float coverage_multiplier = 0.4;
uniform float density_factor = 0.2;
uniform float texture_scale = 1.0;
uniform float weather_texture_scale = 1.0;
// const float texture_scale = 4.0;

uniform float cloud_speed = 100.8;

uniform vec3 cloudColorTop = (vec3(169., 149., 149.)*(1.5/255.));
uniform vec3 cloudColorBottom =  (vec3(65., 70., 80.)*(1.5/255.));
#define CLOUDS_AMBIENT_COLOR_TOP cloudColorTop
#define CLOUDS_AMBIENT_COLOR_BOTTOM cloudColorBottom

#define CLOUDS_MIN_TRANSMITTANCE 1e-1
#define CLOUDS_TRANSMITTANCE_THRESHOLD 1.0 - CLOUDS_MIN_TRANSMITTANCE

float getHeightFractionForPoint(vec3 position)
{
  // Get global fractional position in cloud zone
  float cloudMinHeight = AABBmin.y;
  float cloudMaxHeight = AABBmax.y;
  float height_fraction = (position.y-cloudMinHeight)/(cloudMaxHeight - cloudMinHeight);
  return clamp(height_fraction, 0.0, 1.0);
}

float getDensityForCloud(float heightFraction, float cloudType)
{
	float stratusFactor = 1.0 - clamp(cloudType * 2.0, 0.0, 1.0);
	float stratoCumulusFactor = 1.0 - abs(cloudType - 0.5) * 2.0;
	float cumulusFactor = clamp(cloudType - 0.5, 0.0, 1.0) * 2.0;

	vec4 baseGradient = stratusFactor * STRATUS_GRADIENT + stratoCumulusFactor * STRATOCUMULUS_GRADIENT + cumulusFactor * CUMULUS_GRADIENT;
	// gradicent computation (see Siggraph 2017 Nubis-Decima talk)
	//return remap(heightFraction, baseGradient.x, baseGradient.y, 0.0, 1.0) * remap(heightFraction, baseGradient.z, baseGradient.w, 1.0, 0.0);
	return smoothstep(baseGradient.x, baseGradient.y, heightFraction) - smoothstep(baseGradient.z, baseGradient.w, heightFraction);

}

/*
1. The first step is to retrieve the four low-frequency noise values required
   to build a basic cloud shape. We sample the first 3D texture, containing
   low-frequency octaves.
2. We will use the first channel, which contains the Perlin-Worley noise, to
   establish our base cloud shape.
3. Though the basic Perlin-Worley noise provides a reasonable cloud density
   function, it lacks the detail of a realistic cloud. We use a remapping function
   to add the three other low-frequency noises to the edges of the Perlin-Worley
   noise. This method of combining noises prevents the interior of the Perlin-
   Worley cloud shape from becoming non-homogenous and also ensures that
   we only add detail in the areas that we can see.
4. To determine the type of cloud we are drawing, we compute our density
   height function based on the cloud type attribute from our weather texture.
5. Next, we multiply the base cloud shape by the density height function to
   create the correct type of cloud according to the weather data.

*/

#define CLOUD_TOP_OFFSET 50.0
const vec3 windDirection = (vec3(1.0, 0.0, 0.0));
float sampleCloudDensity(vec3 rayPos, int lod)
{
  vec3 uvw = uvwFromWorldPos(rayPos);
  float height_fraction = getHeightFractionForPoint(rayPos); 
  if (height_fraction < 0.0 || height_fraction > 1.0) return 0.0;
	// vec3 animation = height_fraction * windDirection * CLOUD_TOP_OFFSET + windDirection * time * cloud_speed;
  vec3 animation = height_fraction*windDirection*CLOUD_TOP_OFFSET + (windDirection + vec3(0.0, 0.1, 0.0))*time*cloud_speed;
  vec3 moving_uvw = uvwFromWorldPos(rayPos+animation);
  // Original sample had low frequency noise as a 32x32x32 texture
  // int level_of_detail = int(texture_size.x/32);
  // int lod = 128/32;

  // We read the low-frequency Perlin-Worley and Worley noises
  vec4 low_frequency_noises = textureLod(perlinWorley, uvw*texture_scale, lod); 

  // Build FBM out of the low frequency noises:
  float low_freq_fbm = (low_frequency_noises.g * 0.625)
                       + (low_frequency_noises.b * 0.25)
                       + (low_frequency_noises.a * 0.125);
  // Define the base cloud shape by dilating it with the low-frequency FBM made of worley noise:
  float base_cloud = remap(low_frequency_noises.r, -(1.0-low_freq_fbm), 1.0, 0.0, 1.0);

	float density_height_gradient = getDensityForCloud(height_fraction, 1.0);
	base_cloud *= (density_height_gradient/height_fraction);

  vec4 weather_data = textureLod(weather, weather_texture_scale*moving_uvw.xz, 4); // We use uvw.xz because we want weather to be applied in horizontal xz plane
  // Remember! Cloud coverage is stored in weather's red channel:
  float cloud_coverage = weather_data.r*coverage_multiplier;
  float base_cloud_with_coverage = remap(base_cloud, cloud_coverage, 1.0, 0.0, 1.0);
  base_cloud_with_coverage *= cloud_coverage;
  // return base_cloud_with_coverage;

	// return clamp(base_cloud_with_coverage, 0.0, 1.0);
  // if (expensive)
  vec3 high_frequency_noises = textureLod(perlinWorley, moving_uvw*texture_scale, 0).gba; // Only get worley parts
  float high_freq_fbm = (high_frequency_noises[0]*0.625)
                        + (high_frequency_noises[1] * 0.25)
                        + (high_frequency_noises[2] * 0.125);
  

  // Transition from wispy shapes to billowy shapes over height
  float high_freq_noise_modifier = mix(high_freq_fbm, 1.0-high_freq_fbm, clamp(height_fraction*10.0, 0.0, 1.0));

  // Erode the base cloud shape with the distorted high-frequency worley noises
  base_cloud_with_coverage = base_cloud_with_coverage - high_freq_noise_modifier * (1.0 - base_cloud_with_coverage);
  base_cloud_with_coverage = remap(base_cloud_with_coverage*2.0, high_freq_noise_modifier * 0.2, 1.0, 0.0, 1.0);
  // return base_cloud_with_coverage;
  // return base_cloud_with_coverage;
  // float final_cloud = remap(base_cloud_with_coverage, high_freq_noise_modifier*0.2, 1.0, 0.0, 1.0);
  // return final_cloud;
  return clamp(base_cloud_with_coverage, 0.0, 1.0);
  return base_cloud_with_coverage;
}

#define STEPS_LIGHT 6
vec3 raymarchToLight(vec3 o, float stepSize, vec3 lightDir, float mu)
{
  float cloud_height = getHeightFractionForPoint(o);
  Ray light_ray;
  light_ray.origin = o;
  light_ray.dir = normalize(lightDir);
  float tnear, tfar; // tnear should always be 0
  bool hit = RayAABBIntersection(light_ray, AABBmin, AABBmax, tnear, tfar);

  float light_ray_density = 0.0;
  float stepLength = (tfar-tnear)/float(STEPS_LIGHT);
  if (hit)
  {


    vec3 light_ray_pos = o;
    float t = tnear;
    for (int i = 0; i < STEPS_LIGHT; i++)
    {
      int sample_lod = 0;
      if (light_ray_density > 0.3)
      {
        sample_lod = 3;
      }
      t += stepLength;
      light_ray_pos = light_ray.origin + t*light_ray.dir;

      light_ray_density += sampleCloudDensity(light_ray_pos, sample_lod);
      // light_ray_pos += normalize(lightDir)*stepSize;
    }
    // vec3 beers_law = vec3(0.05);
  }

  vec3 beers_law = multipleOctaves(light_ray_density, mu, stepLength);
    //Return product of Beer's law and powder effect depending on the 
    //view direction angle with the light direction.
	return mix(beers_law * 2.0 * (1.0-(exp(-stepSize*light_ray_density*2.0*sigmaE))), beers_law, 0.5+0.5*mu);
}

// float raymarchToLight(vec3 o, float stepSize, vec3 lightDir, float originalDensity, float lightDotEye)
// {

// 	vec3 startPos = o;
// 	float ds = stepSize * 6.0;
// 	vec3 rayStep = lightDir * ds;
// 	const float CONE_STEP = 1.0/6.0;
// 	float coneRadius = 1.0; 
// 	float density = 0.0;
// 	float coneDensity = 0.0;
// 	float invDepth = 1.0/ds;
// 	float sigma_ds = -ds*absorption;
// 	vec3 pos;

// 	float T = 1.0;

// 	for(int i = 0; i < 6; i++)
// 	{
//     pos = startPos + coneRadius;
// 		// pos = startPos + coneRadius*noiseKernel[i]*float(i);

// 		float heightFraction = getHeightFractionForPoint(pos);
// 		if(heightFraction >= 0)
// 		{
			
// 			float cloudDensity = sampleCloudDensity(pos, 0);
// 			if(cloudDensity > 0.0)
// 			{
// 				float Ti = exp(cloudDensity*sigma_ds);
// 				T *= Ti;
// 				density += cloudDensity;
// 			}
// 		}
// 		startPos += rayStep;
// 		coneRadius += CONE_STEP;
// 	}

// 	//return 2.0*T*powder((originalDensity));//*powder(originalDensity, 0.0);
// 	return T;
// }

float HG( float sundotrd, float g) {
	float gg = g * g;
	return (1. - gg) / pow( 1. + gg - 2. * g * sundotrd, 1.5);
}


vec4 raymarchCloud(Ray ray_world, Ray ray_viewspace, float tnear, float tfar, vec3 view_space_obstacle)
{
 
  // vec4 dst = vec4(vec3(1.0),0.0);
  vec3 color = vec3(0.0);
  vec3 totalTransmittance = vec3(1.0);
  float t = tnear;
  vec3 rayPos = ray_world.origin + ray_world.dir*tnear;

  float density = 0.0;
  
  float light_dot_eye = dot(normalize(light_direction), normalize(ray_world.dir));
  

  float sigma_ds = -StepSize*density_factor;
  float T = 1.0;

  float mu = 0.5+0.5*dot(normalize(ray_world.dir), normalize(light_direction));
	// float phaseFunction = mix(HenyeyGreenstein(-0.3, mu), HenyeyGreenstein(0.3, mu), 0.7);
  float phaseFunction = 1.0;
  // vec3 sunLight = sunLightColour * sun_power;
  vec3 sunLight = vec3(1.0)*sun_power;

  for (int i = 0; i < STEPS_PRIMARY; i++)
  {
    float density_sample = sampleCloudDensity(rayPos, i/40);
    vec3 sampleSigmaS = sigmaS*density_sample;
    vec3 sampleSigmaE = sigmaE*density_sample;
    if (density_sample > 0.0)
    {
      float height = getHeightFractionForPoint(rayPos);
      vec3 ambientLight = mix(CLOUDS_AMBIENT_COLOR_BOTTOM, CLOUDS_AMBIENT_COLOR_TOP, height);
      // vec3 ambientLight = vec3(1.0) * mix((0.2), (0.8), height);
      // float light_density = raymarchToLight(rayPos, StepSize*0.1, light_direction, density_sample, light_dot_eye);
      vec3 luminance = 0.1*ambientLight + 
          sunLight * phaseFunction * raymarchToLight(rayPos, 0.1*StepSize, light_direction, mu);
      
      luminance *= sampleSigmaS;

      vec3 transmittance = exp(-sampleSigmaE * StepSize);
      // float light_density = rayMarchToLight(rayPos, StepSize*0.1, light_direction, mu);
      color += 
          totalTransmittance * (luminance - luminance * transmittance) / sampleSigmaE; 
      totalTransmittance *= transmittance;  

      if(length(totalTransmittance) <= 0.001){
          totalTransmittance = vec3(0.0);
          break;
      }
    }

    // Front-to-back compositing
    // dst.a += (1.0-dst.a)*density_sample*density_factor;
    vec3 ray_viewspace_position = ray_viewspace.origin + ray_viewspace.dir*t;
    if (t > tfar) break;
    if (ray_viewspace_position.z < view_space_obstacle.z) break; // TODO: Figure out how to integrate until exact t value
    t += StepSize;
    rayPos = ray_world.origin + ray_world.dir*t;
  }
  vec4 dst = vec4(color, 1.0-length(totalTransmittance));
  // col.a = 1.0-length(totalTransmittance);
  return dst;
}

// vec4 raymarchCloud(Ray ray_world, Ray ray_viewspace, float tnear, float tfar, vec3 view_space_obstacle)
// {
 
//   // vec4 dst = vec4(vec3(1.0),0.0);
//   vec4 col = vec4(0.0);
//   float t = tnear;
//   vec3 rayPos = ray_world.origin + ray_world.dir*tnear;

//   float density = 0.0;
  
//   float light_dot_eye = dot(normalize(light_direction), normalize(ray_world.dir));
  

//   float sigma_ds = -StepSize*density_factor;
//   float T = 1.0;

//   float mu = 0.5+0.5*dot(normalize(ray_world.dir), normalize(light_direction));

//   for (int i = 0; i < STEPS_PRIMARY; i++)
//   {
//     float density_sample = sampleCloudDensity(rayPos, i/40);
//     if (density_sample > 0.0)
//     {
//       float height = getHeightFractionForPoint(rayPos);
//       vec3 ambientLight =CLOUDS_AMBIENT_COLOR_BOTTOM;
//       // float light_density = raymarchToLight(rayPos, StepSize*0.1, light_direction, density_sample, light_dot_eye);
//       float light_density = rayMarchToLight(rayPos, StepSize*0.1, light_direction, mu);
//       float scattering = mix(HG(light_dot_eye, -0.08), HG(light_dot_eye, 0.08), clamp(light_dot_eye*0.5+0.5, 0.0, 1.0));
//       scattering = max(scattering, 1.0);

//       float powder_term = powder(density_sample);
//       vec3 bg = vec3(0.0,0.74902, 1.0);
//       // vec3 S = mix(ambientLight*1.8, bg, 0.2);
//       // S = 0.6 * density_sample * mix(S, scattering*vec3(0.0, 1.0, 0.0)*vec3(1.1, 1.1, 0.95), powder_term*light_density);
// 			vec3 S = 0.6*mix( mix(ambientLight*1.8, bg, 0.2), scattering*SUN_COLOR, powder_term*light_density) * density_sample;
//       float dTrans = exp(density_sample*sigma_ds);
//       vec3 Sint = (S - S*dTrans) * (1.0 / density_sample);
//       col.rgb += T * Sint;
//       T *= dTrans;

//       // vec3 S = 0.6*mix(mix(ambientLight*1.8, ))
//     }

//     // Front-to-back compositing
//     // dst.a += (1.0-dst.a)*density_sample*density_factor;
//     vec3 ray_viewspace_position = ray_viewspace.origin + ray_viewspace.dir*t;
//     if (T < 0.001) break;
//     if (t > tfar) break;
//     if (ray_viewspace_position.z < view_space_obstacle.z) break; // TODO: Figure out how to integrate until exact t value
//     t += StepSize;
//     rayPos = ray_world.origin + ray_world.dir*t;
//   }
//   col.a = 1.0-T;
//   return col;
// }

vec3 ACESFilm(vec3 x){
  return x;
    return clamp((x * (2.51 * x + 0.03)) / (x * (2.43 * x + 0.59) + 0.14), 0.0, 1.0);
}

void main()
{
  ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy);
  ivec2 size = imageSize(OutputFrag);
  if (fragCoord.x > viewport.z || fragCoord.y > viewport.w) return;

  Ray ray_viewspace;
  // Create ray origin and direction
  // Transfer from screen space -> clip space -> world space 
  // The ray is at clipspace coords x,y and shoots a ray into the scene, (i.e. z=1)
  vec4 ray_dir_ndc = vec4(fragToClipSpace(fragCoord).xy, 1.0 , 1.0);
  vec4 ray_dir_view = inv_proj*ray_dir_ndc;

  // I don't know why this works, but it does
  ray_dir_view = vec4(ray_dir_view.xy, -1.0, 0.0);
  vec4 ray_dir_world = (inv_view*ray_dir_view);

  // The same for ray origin, only that this time the coordinate starts at the near plane, i.e. z=-1
  vec4 ray_origin_ndc = vec4(fragToClipSpace(fragCoord), 1.0);
  vec4 ray_origin_view = inv_proj*ray_origin_ndc;
  ray_origin_view /= ray_origin_view.w; 
  vec4 ray_origin_world = inv_view*ray_origin_view;


  Ray ray_world;
  ray_world.origin = ray_origin_world.xyz;
  ray_world.dir = normalize(ray_dir_world.xyz);

  ray_viewspace.origin = ray_origin_view.xyz;
  ray_viewspace.dir = normalize(ray_dir_view.xyz);
  float tnear, tfar;
  bool hit = RayAABBIntersection(ray_world, AABBmin, AABBmax, tnear, tfar);

  // Boid position (if there is one) in view space:
  vec3 view_space_obstacle = VSPositionFromDepth(fragCoordToUV(fragCoord));

  vec4 dst = vec4(vec3(1.0),0.0);
  if (hit)
  {
    // dst = vec4(texture(perlinWorley, texture_scale*uvwFromWorldPos(ray_world.origin + ray_world.dir*tnear)).bbb, 1.0);
    dst = raymarchCloud(ray_world, ray_viewspace, tnear, tfar, view_space_obstacle);
    dst.rgb *= 0.5;
    dst.rgb *= ACESFilm(dst.rgb);
    dst.rgb = pow(dst.rgb, vec3(0.4545));
  }
  imageStore(OutputFrag, fragCoord, dst);
}
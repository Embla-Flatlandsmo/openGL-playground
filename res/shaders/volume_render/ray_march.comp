#version 430

layout(binding=0) uniform sampler3D perlin; 
layout(binding=1) uniform sampler2D weather;
layout(binding=2) uniform sampler2D depth;
// layout (binding = 2) uniform sampler1D TexTransferFunc;
// layout (binding = 3) uniform sampler3D TexVolumeGradient;

uniform vec3 VolumeGridSize;
uniform vec3 AABBmin;
uniform vec3 AABBmax;

uniform float StepSize;

uniform mat4 inv_vp;
uniform mat4 inv_view;
uniform mat4 inv_proj;
uniform vec4 viewport;

layout (local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
layout (rgba16f, binding = 0) uniform image2D OutputFrag;

// #define FAST

#ifdef FAST
	#define STEPS_PRIMARY 16
#else
	#define STEPS_PRIMARY 200
#endif


// Takes a number in a given range, and repositions it in a new range
float remap(float x, float x_min, float x_max, float new_min, float new_max)
{
    return (((x - x_min) / (x_max - x_min)) * (new_max - new_min)) + new_min;
}

struct Ray { vec3 Origin; vec3 Dir; };
//=============== COORDINATE UTILITIES ===============//
bool isInsideAABB(vec3 p)
{
  float eps = 1e-4;
  return (p.x > AABBmin.x-eps) && (p.y > AABBmin.y-eps) && (p.z > AABBmin.z-eps) &&
         (p.x < AABBmax.x+eps) && (p.y < AABBmax.y+eps) && (p.z < AABBmax.z+eps);
}

bool IntersectBox (Ray r, vec3 boxmin, vec3 boxmax, out float tnear, out float tfar)
{
  vec3 invR = vec3(1.0) / r.Dir;
  
  vec3 tbbmin = invR * (boxmin - r.Origin);
  vec3 tbbmax = invR * (boxmax - r.Origin);
   
  vec3 tmin = min(tbbmin, tbbmax);
  vec3 tmax = max(tbbmin, tbbmax);
  
  tnear = max(max(tmin.x, tmin.y), tmin.z);
  tfar  = min(min(tmax.x, tmax.y), tmax.z);

  return tfar > tnear;
}

bool RayAABBIntersection (Ray r, vec3 bbmin, vec3 bbmax, 
                          out float rtnear, out float rtfar)
{
 
  float tnear, tfar;
  bool hit = IntersectBox(r, bbmin, bbmax, tnear, tfar);

  tnear = max(tnear, 0.0);

  rtnear = tnear;
  rtfar  = tfar;

  return hit;
}

vec3 uvwFromWorldPos(vec3 pos)
{
  vec3 bbsize = AABBmax-AABBmin;

  // Bring pos to world origin
  vec3 centered_pos = pos-AABBmin;

  // Divide by bbsize to get coordinates on [0,1]
  return centered_pos/bbsize;
  // return clamp(centered_pos/bbsize, 0.0, 1.0);
}


// Finds fragment coordinate fragCoord.x = [0,1920], fragCoord.y=[0,1080]
// and converts it to normalized device coordinates [-1, 1]
vec3 fragToClipSpace(uvec2 fragCoord)
{
  vec2 ndc = 2.0*vec2(fragCoord.xy-viewport.xy)/viewport.zw - 1.0;
  return vec3(ndc, -1.0);
}

// Normalized Device Coordinates (Clip Space coordinates) [-1,1] to screen position [0,1]
vec2 ndcToScreenPos(vec2 ndc)
{
  return (ndc*0.5+0.5);
}


//=============== CLOUD UTILITIES ===============//
vec4 sampleDensity(vec3 rayPos)
{
  vec3 uvw = uvwFromWorldPos(rayPos);
  return texture(perlin, uvw);
}


void main()
{
  ivec2 fragCoord = ivec2(gl_GlobalInvocationID.xy); // 1920x1080
  ivec2 size = imageSize(OutputFrag);

  if (fragCoord.x > size.x || fragCoord.y > size.y) return;

  Ray r;

  // Create ray origin and direction
  // Transfer from screen space -> clip space -> world space 

  // The ray is at clipspace coords x,y and shoots a ray into the scene, (i.e. z=1)
  vec4 ray_dir_ndc = vec4(fragToClipSpace(fragCoord).xy, 1.0 , 1.0);
  vec4 ray_dir_view = inv_proj*ray_dir_ndc;

  // I don't know why this works, but it does
  ray_dir_view = vec4(ray_dir_view.xy, -1.0, 0.0);
  vec4 ray_dir_world = (inv_view*ray_dir_view);

  // Doing it like this makes it a bit distorted
  // vec4 ray_dir_world = inv_vp*ray_dir_ndc;
  // ray_dir_world = ray_dir_world/ray_dir_world.w;

  // The same for ray origin, only that this time the coordinate starts at the near plane, i.e. z=-1
  vec4 ray_origin_ndc = vec4(fragToClipSpace(fragCoord), 1.0);
  vec4 ray_origin_world = inv_vp*ray_origin_ndc;
  ray_origin_world = ray_origin_world/ray_origin_world.w;

  // From https://www.scratchapixel.com/lessons/3d-basic-rendering/ray-tracing-generating-camera-rays/generating-camera-rays
  // Doesn't work, though!
  // vec4 rayPWorld = inv_vp*vec4(fragToClipSpace(fragCoord), 1.0);
  // r.Dir = normalize((rayPWorld/rayPWorld.w - ray_origin_world).xyz);


  r.Origin = ray_origin_world.xyz;
  r.Dir = normalize(ray_dir_world.xyz);

  float tnear, tfar;
  bool hit = RayAABBIntersection(r, AABBmin, AABBmax, tnear, tfar);

  vec4 dst = vec4(vec3(1.0),0.0);
  // // float n = 0.1;
  // // float f = 350.0;
  // vec4 obstacle_clip_pos = texture(depth, ray_origin_ndc.xy);

  // // vec4 obstacle_world_pos = inv_vp*vec4(obstacle_clip_pos.xy, (obstacle_clip_pos-0.1)/350.0, 1.0);
  // vec4 obstacle_world_pos = vec4(1.0);
  // // vec4 depth_world = inv_vp*vec4(ray_origin_ndc.xy, obstacle_clip_pos.z/255.0, 1.0);
  // obstacle_world_pos = obstacle_world_pos/obstacle_world_pos.w;
  // obstacle_world_pos.w = 0.97;

  if (hit)
  {

    vec3 rayPos = r.Origin + r.Dir*tnear;
    for (int i = 0; i < STEPS_PRIMARY; i++)
    {
      vec4 val = sampleDensity(rayPos);
      float scalar = (val.r+val.g+val.b)/3.0;
      // float scalar = 1.0;
      if (val.r > 0.8)
        dst.a += (1.0-dst.a)*scalar*0.1;


      // dst.a += (1.0-dst.a)*scalar*0.1;
      if (dst.a > 0.8) break;

      if (!isInsideAABB(rayPos)) break;
      rayPos += r.Dir*StepSize;
    }
  }

  imageStore(OutputFrag, fragCoord, dst);
}
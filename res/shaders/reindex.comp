#version 430

layout( local_size_x = 1024, local_size_y = 1, local_size_z = 1 ) in;

layout(std140, binding=0) buffer particlePositions
{
    vec4 Positions[];
};

layout(std140, binding=1) buffer particleVelocities
{
    vec4 Velocities[];
};

layout(std430, binding=3) buffer particleIndex
{
    uint particleIndices[];
};

layout(std430, binding=4) readonly buffer prefixSum
{
    uint prefixSums[];
};

layout(std430, binding=5) buffer bucketSize
{
    uint bucketSizes[];
};

layout(std140, binding=6) buffer particlePositions_read
{
    vec4 Positions_read[];
};

layout(std140, binding=7) buffer particleVelocities_read
{
    vec4 Velocities_read[];
};


uniform vec3 boundingBoxLow;
uniform vec3 boundingBoxHigh;
uniform uvec3 gridRes;
uniform uint numBoids;

void main(void) {
    uint gid = gl_GlobalInvocationID.x;
    if (gid >= numBoids) {
        return;
    }
    vec3 diagonal = boundingBoxHigh-boundingBoxLow;
    vec3 range = diagonal/gridRes;
    uvec3 vgridIdx = uvec3((Positions[gid].xyz-boundingBoxLow)/range);
    uint cellIdx =  uint(gridRes.x * gridRes.y * vgridIdx.z + gridRes.x * vgridIdx.y + vgridIdx.x);
    
    uint particleIdx = prefixSums[cellIdx]+atomicAdd(bucketSizes[cellIdx],-1)-1;
    // Maybe the indexing here is wrong??
    // Positions[particleIdx] = Positions_read[gid];
    // Velocities[particleIdx] = Velocities_read[gid];
    // particleIndices[gid]=particleIdx;
}